## Parent epic

Epic E3: authentication and roles (P0) — #17

## Objective

Configure Supabase Auth, implement the Next.js middleware for session management, create the `auth/callback/route.ts` OAuth handler, set up all required Supabase migrations (user_profiles, user_roles, subjects seed, helper functions, trigger), and enable RLS policies — establishing the complete auth foundation for E4–E12.

---

## Background

From `docs/ARCHITECTURE.md` section 4.1:
> "Enable: email/password signups with email confirmation required. Google OAuth provider enabled."

From section 6.2:
> "`handle_new_user()` trigger — auto-creates profile and assigns `student` role on signup"

This task combines the Supabase configuration steps (done in Dashboard + migrations) with the Next.js code (middleware + callback route).

---

## Part 1: Supabase Dashboard configuration

### 1.1 Auth settings
In **Supabase Dashboard → Authentication → Settings**:
- Enable email confirmations: **ON**
- Email OTP expiry: 3600 seconds (1 hour)
- Site URL: `http://localhost:3000` (development), update to Vercel URL for production
- Redirect URLs: `http://localhost:3000/auth/callback` (development)

### 1.2 Google OAuth provider
In **Supabase Dashboard → Authentication → Providers → Google**:
- Enable Google
- Add Client ID and Client Secret from [Google Cloud Console](https://console.cloud.google.com)
- Authorized redirect URI: `https://<supabase-project>.supabase.co/auth/v1/callback`

---

## Part 2: Supabase migrations

Create migration files in `supabase/migrations/` in this order:

### Migration 1: `<ts>_create_enums.sql`
All enum types from `docs/ARCHITECTURE.md` section 5.1:
```sql
create type public.role_enum as enum ('student', 'parent', 'tutor', 'admin');
create type public.level_enum as enum ('o_levels', 'a_levels');
create type public.exam_board_enum as enum ('cambridge', 'edexcel', 'other', 'unspecified');
create type public.request_status_enum as enum (
  'new', 'payment_pending', 'ready_to_match', 'matched', 'active', 'paused', 'ended'
);
create type public.package_status_enum as enum ('pending', 'active', 'expired');
create type public.payment_status_enum as enum ('pending', 'paid', 'rejected', 'refunded');
create type public.match_status_enum as enum ('matched', 'active', 'paused', 'ended');
create type public.session_status_enum as enum (
  'scheduled', 'done', 'rescheduled', 'no_show_student', 'no_show_tutor'
);
```

### Migration 2: `<ts>_create_subjects.sql`
```sql
create table public.subjects (
  id smallint generated by default as identity primary key,
  code text not null unique,
  name text not null,
  active boolean not null default true,
  sort_order int not null default 0
);

insert into public.subjects (code, name, sort_order) values
  ('math',        'Mathematics',      1),
  ('physics',     'Physics',          2),
  ('chemistry',   'Chemistry',        3),
  ('biology',     'Biology',          4),
  ('english',     'English',          5),
  ('cs',          'Computer Science', 6),
  ('pak_studies', 'Pakistan Studies', 7),
  ('islamiyat',   'Islamiyat',        8),
  ('urdu',        'Urdu',             9);
```

### Migration 3: `<ts>_create_user_profiles.sql`
```sql
create table public.user_profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  display_name text not null,
  whatsapp_number text,
  timezone text not null default 'Asia/Karachi',
  primary_role public.role_enum not null default 'student',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table public.user_roles (
  user_id uuid references public.user_profiles(user_id) on delete cascade,
  role public.role_enum not null,
  created_at timestamptz not null default now(),
  primary key (user_id, role)
);

-- Helper functions
create or replace function public.has_role(p_uid uuid, p_role public.role_enum)
returns boolean language sql stable as $$
  select exists (select 1 from public.user_roles ur where ur.user_id = p_uid and ur.role = p_role);
$$;

create or replace function public.is_admin(p_uid uuid)
returns boolean language sql stable as $$
  select public.has_role(p_uid, 'admin');
$$;

create or replace function public.is_tutor(p_uid uuid)
returns boolean language sql stable as $$
  select public.has_role(p_uid, 'tutor');
$$;

-- Auto-create profile on signup
create or replace function public.handle_new_user()
returns trigger language plpgsql security definer as $$
begin
  insert into public.user_profiles (user_id, display_name, timezone, primary_role)
  values (new.id, coalesce(new.raw_user_meta_data->>'name', 'New User'), 'Asia/Karachi', 'student')
  on conflict (user_id) do nothing;

  insert into public.user_roles (user_id, role)
  values (new.id, 'student')
  on conflict do nothing;

  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- RLS
alter table public.user_profiles enable row level security;
alter table public.user_roles enable row level security;

create policy "profiles_select_own_or_admin"
  on public.user_profiles for select to authenticated
  using (user_id = auth.uid() or public.is_admin(auth.uid()));

create policy "profiles_update_own_or_admin"
  on public.user_profiles for update to authenticated
  using (user_id = auth.uid() or public.is_admin(auth.uid()))
  with check (user_id = auth.uid() or public.is_admin(auth.uid()));

create policy "roles_select_own_or_admin"
  on public.user_roles for select to authenticated
  using (user_id = auth.uid() or public.is_admin(auth.uid()));

create policy "roles_admin_write"
  on public.user_roles for all to authenticated
  using (public.is_admin(auth.uid()))
  with check (public.is_admin(auth.uid()));
```

---

## Part 3: Next.js middleware

Create `middleware.ts` at project root:

```ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return request.cookies.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  const { data: { user } } = await supabase.auth.getUser()

  const protectedPaths = ['/dashboard', '/tutor', '/admin']
  const isProtected = protectedPaths.some(p => request.nextUrl.pathname.startsWith(p))

  if (isProtected && !user) {
    const url = request.nextUrl.clone()
    url.pathname = '/auth/sign-in'
    url.searchParams.set('next', request.nextUrl.pathname)
    return NextResponse.redirect(url)
  }

  return supabaseResponse
}

export const config = {
  matcher: ['/dashboard/:path*', '/tutor/:path*', '/admin/:path*'],
}
```

---

## Part 4: Auth callback route

Create `app/auth/callback/route.ts`:

```ts
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { NextResponse, type NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/dashboard'

  if (code) {
    const cookieStore = await cookies()
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() { return cookieStore.getAll() },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          },
        },
      }
    )
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    if (!error) {
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  return NextResponse.redirect(`${origin}/auth/sign-in?error=auth_callback_failed`)
}
```

---

## Proposed steps

1. Apply Supabase Auth settings in Dashboard
2. Run migrations in order (enums → subjects → user_profiles)
3. Create `middleware.ts`
4. Create `app/auth/callback/route.ts`
5. Create `app/auth/sign-up/page.tsx` (S3.1)
6. Create `app/auth/sign-in/page.tsx` (S3.1)
7. Create `app/auth/verify/page.tsx`
8. Create `app/dashboard/page.tsx` with role-based redirect (T3.2)
9. Test full signup → verify → login flow
10. Test Google OAuth flow

---

## Definition of done

- [ ] All enum types are created in Supabase
- [ ] `subjects` table seeded with 9 MVP subjects
- [ ] `user_profiles` and `user_roles` tables exist with RLS
- [ ] `handle_new_user()` trigger fires on signup
- [ ] `has_role()`, `is_admin()`, `is_tutor()` functions exist
- [ ] Middleware protects `/dashboard`, `/tutor`, `/admin`
- [ ] `auth/callback/route.ts` exchanges code for session correctly
- [ ] Email verification is enforced (unverified users see verify screen)
- [ ] Google OAuth works end-to-end

---

## References

- `docs/ARCHITECTURE.md` — section 4.1 (Auth), section 5.2 (subjects), section 5.3 (user_profiles + user_roles), section 6.1–6.5 (RLS + helpers), section 8.1 (signup workflow)
- `docs/MVP.md` — section 10.1 (student account requirements)
